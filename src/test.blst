 function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list. function main(String args[]) : int {
	
	int a = 0.0;

	String s = "test";

	return 0;
}

for (int i = 0; i < 20; i++)
{
}

//This is a single line comment

/*
multi line
*/

//This file contains information as to the goal for the B-list syntax.
//Comments are used graciously in this file in order to explain how the 
//syntax will work/operate. 


//Example 1 (test.blst), B-list includes/Selects/function headers

#include "math.blst"			//Include the math blist file. In B-list, all files are cammel case.
#include "test2.blst"			//include second test file

#select GARBAGE_COLLECT	true		//This line sets the Garbage collection param to true, so garbage 
					//collection is enabled. 

#select MEM_USAGE 512000000		//Selects the maximum allowable memory usage for this program to 512 MB (in bytes).


//create global variables. global variables are shared across files. 
int globalInt = 0;

//This is a comment

/*
* This is a multi
* line comment
*/

//begin function block
//notice the format: function name(<args>) : <return type> {}  
function main(String args[]) : int {		//This is how the main method is set in B-list. The args[] parameter works the same
						//as it works in java, where values can be passed into the function.
	
	//all function code is indented under the parent. Each line is ended with semicolon. 
	String arg1 = args[0];		//this is how you access an element in an array.
	
	//allocate a new array we can do it one of two ways
	//1
	String[] array1 = [30];
	//2 dynamically allocate. Notice, this does not need to be freed in this program due to our inclusion of Garbage collection
	String[] array2 = memAl(30 * sizeof(String));

	//if we want to have to free it, for whatever reason, you can exclude it from garbage collection as follows:
	#exclude GARBAGE_COLLECT				//exclude is a keyword used to exclude from a select param. 
	String[] array3 = memAl(30 * sizeof(String));		//format is #Exclude <select param name>
	
	//because we have allocated dynamically and excluded it from garbage collection, we must free it ourself.
	free(array3);		
	
	//we can also select inline. selecting inline means any continueing code follows select. 
	//example, we can select GARBAGE_COLLECT to false if we want, and the rest of the program will no longer use it.
	#Select GARBAGE_COLLECT false
	
	//definitions of standard variables are as follows
	int a = 0;
	int a;
	String b = "";
	String b;
	float c = 0.0f;
	float c;	
	double d = 0.0;
	double d;
	char e = '';
	char e;
	long f = 100000L;
	long f;
		
	//definitions of non-standard variables are as follows
	var g = "";		//var evaluates to any data type. It is up to the programmer to know what they are doing
	var g;			//when using var. 
	
	//B-list will use x86 Assembly. This is how you write in-line assembly in B-list.
	#setState ASSEMBLY_x86 true	//we use the SetState keyword to set the compiler to a specific state for the next few lines.
					//the state is passed in.	
		//now we can write x86 assembly code. The assemby code we write is a higher level version (ie registers we specify may not be 
		//the registers the compiler uses). 
		mov eax, ebx			//these are dummy commands, the important thing to note is one command per line. 
		add eax, 1
		inc eax

	#endState			//the EndState keyword changes the compiler state back to the state it was prior to SetState.
	
	//B-list can also allow in-line binary to be written	
	#setState BINARY true
		0000 0000 0000 0000		//note the format for the binary. four four-bit clusters per line. 
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
		0000 0000 0000 0000
	#endState			//Ends the BINARY state.

	//for loops are written as follows
	for (int i = 0; i < 10; i ++)
	{
		//the body of the for loop. It can be broken as follows:
		break loop; //note we can break it by simply saying break. The break command is: break <optional specification>;
	}

	//if statements
	if (true)
	{
		//perform some function. We can break the if statment as follows:
		break con; //stands for break conditional
	}
	else
	{
		//else statement. We can break the else statement with breakcon.
		break con;
	}	
	
	//switch statements are as follows
	switch ("d")
	{
		case "d":
			//do something
		break case;
		case "e": 
			//do something
		break case;
	}

	return 0;			//return value of 0, lets os know execution was successful
					//-1 means problem. All other values are user-defined and optional. 
}					//this is how you end a function in B-list.